<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>blockgame01(2026 01)</title>
    <style>
        /* *は全てに適用するセレクタ */
        * {
            box-sizing: border-box; /* 要素の幅と高さに境界線とパディングを含める */

            /* 以下の2つはデフォルトの余白を全部消すため */
            margin: 0;
            padding: 0
        }

        body {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .wrap {
            width: 520px
        }

        h1 {
            color: #334155;
            text-align: center;
            margin-bottom: 12px;
            font-size: 20px
        }

        canvas {
            display: block;
            border: 3px solid #667eea;
            border-radius: 8px; /* 角を丸くする */
            margin: 0 auto /* 中央寄せ */
        }

        /* スコアとボタンを横並びにする */
        .info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 14px
        }

        #score {
            color: #667eea;
            font-weight: 700;
            font-size: 20px
        }

        button {
            padding: 8px 14px; /* 8と14は上下と左右の余白 */
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 700
        }

        #start {
            background: #667eea;
            color: #fff
        }

        #reset {
            background: #ef4444;
            color: #fff
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1>2026年1個目のブロック崩し</h1>
        <canvas id="c" width="480" height="600"></canvas>
        <div class="info">
            <div>スコア: <span id="score">0</span></div>
            <div>
                <button id="start">スタート</button>
                <button id="reset">リセット</button>
            </div>
        </div>
    </div>

    <script>
        (function () {
            // 各機能を取得するところ
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            const scoreEl = document.getElementById('score');
            const startBtn = document.getElementById('start');
            const resetBtn = document.getElementById('reset');

            // --- 状態変数 ---
            let score = 0;
            let gameRunning = false; // ゲームが進行中かどうか
            let animationId = null; //アニメーションフレームのIDで停止時に使う

            // --- Paddle ---
            const paddle = { 
                x: canvas.width / 2 - 40, 
                y: canvas.height - 30, 
                width: 80, 
                height: 10, 
                speed: 7,
                dx: 0 // 現在の水平速度
            };

            // --- Ball (with trail) ---
            const ball = { 
                x: canvas.width / 2, 
                y: canvas.height / 2, 
                radius: 6, 
                dx: 3, 
                dy: -3, 
                trail: [] // 軌跡の位置を保存する配列
            };

            //破片のエフェクトを格納する配列
            let particles = []; // {x,y,vx,vy,color,life}

            // --- Bricks config ---
            const brickRows = 8, 
            brickCols = 8, 
            brickPadding = 5, 
            brickOffsetTop = 40, 
            brickOffsetLeft = 10;
            let brickWidth = Math.floor((canvas.width - brickOffsetLeft * 2 - (brickCols - 1) * brickPadding) / brickCols);
            const brickHeight = 20; //ブロックの高さは固定
            let bricks = []; //ブロックを格納する2次元配列

            /* ここでは、ブロックの初期化を行う関数を定義している。
               各ブロックには位置（x, y）、状態（status）、および色（color）が設定される。 */
            function initBricks() {
                bricks = []; //ここで初期化
                const colors = 
                ['#e74c3c', 
                '#e67e22', 
                '#f39c12', 
                '#27ae60', 
                '#4bb7ff', 
                '#d381f4', 
                '#ff7ffd', 
                '#ff3e6b'];
                /* 2次元配列としてブロックを初期化するループ */
                for (let r = 0; r < brickRows; r++) {
                    bricks[r] = [];
                    for (let c = 0; c < brickCols; c++) {
                        /* 各ブロックの位置と状態を設定 */
                        bricks[r][c] = {
                            /* xとyはブロックの位置を計算して設定している。
                               statusは1で、これはブロックが存在することを示す。
                               colorは行番号に基づいてcolors配列から取得され、各行に異なる色が割り当てられる。 */
                            x: brickOffsetLeft + c * (brickWidth + brickPadding),
                            y: brickOffsetTop + r * (brickHeight + brickPadding),
                            // ステータス（1=存在、0=破壊済み）
                            status: 1,
                            color: colors[r] || '#999'
                        };
                    }
                }
            }

            /* ここでは、パーティクルを生成する関数を定義している。*/
            function createParticles(x, y, color, count = 12) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.6) * 6,
                        color: color,
                        life: 1
                    });
                }
            }
            /*ここでは、パーティクルの位置と寿命を更新する関数を定義している。*/
            function updateParticles() {
                particles = particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.18;    // gravity
                    p.vx *= 0.99;    // slight air drag
                    p.life -= 0.03;
                    return p.life > 0;
                });
            }
            /* ここでは、パーティクルを描画する関数を定義している。*/
            function drawParticles() {
                for (const p of particles) {
                    ctx.globalAlpha = Math.max(0, p.life);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 3, 3);
                }
                ctx.globalAlpha = 1;
            }

            /* ここでは、パドルを描画する関数を定義している。*/            
            function drawPaddle() {
                ctx.fillStyle = '#667eea';
                ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            }

            /* ここでは、ボールとその軌跡を描画する関数を定義している。
               ボールの現在位置に加えて、過去の位置を保存したtrail配列を使用して軌跡効果を描画している。 */
            function drawBall() {
                // add current position to trail
                ball.trail.push({ x: ball.x, y: ball.y });
                if (ball.trail.length > 10) ball.trail.shift();

                // draw trail (from oldest to newest -> faint -> strong)
                for (let i = 0; i < ball.trail.length; i++) {
                    const t = ball.trail[i];
                    const alpha = (i / ball.trail.length) * 0.5; // 0..0.5
                    const r = ball.radius * (i / ball.trail.length * 0.8 + 0.2);
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, Math.max(1, r), 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(231,76,60,${alpha})`;
                    ctx.fill();
                    ctx.closePath();
                }

                // main ball
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.closePath();
            }

            /* ここでは、ブロックを描画する関数を定義している。
               各ブロックはその位置（x, y）とサイズ（brickWidth, brickHeight）に基づいて描画される。
               ブロックの色はそのcolorプロパティに基づいて設定され、枠線も描画される。 */
            function drawBricks() {
                for (let r = 0; r < brickRows; r++) {
                    for (let c = 0; c < brickCols; c++) {
                        const b = bricks[r][c];
                        if (!b || b.status === 0) continue;
                        ctx.fillStyle = b.color;
                        ctx.fillRect(b.x, b.y, brickWidth, brickHeight);
                        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(b.x, b.y, brickWidth, brickHeight);
                    }
                }
            }

            /* ここでは、パドルの移動を更新する関数を定義している。
               パドルの位置はその速度（dx）に基づいて更新され、キャンバスの境界内に制限される。 */
            function movePaddle() {
                paddle.x += paddle.dx;
                if (paddle.x < 0) paddle.x = 0;
                if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
            }

            /* ここでは、ボールの移動と衝突検出を更新する関数を定義している。
               ボールの位置はその速度（dx, dy）に基づいて更新され、キャンバスの境界、パドル、およびブロックとの衝突が検出される。
               衝突が発生した場合、ボールの速度が反転し、スコアが更新され、必要に応じてパーティクルが生成される。
               ボールがキャンバスの下端を超えた場合、ゲームオーバーとなり、ゲームがリセットされる。 */
            function moveBall() {
                ball.x += ball.dx;
                ball.y += ball.dy;

                // wall collisions
                if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.dx *= -1;
                if (ball.y - ball.radius < 0) ball.dy *= -1;

                // paddle collision
                if (ball.y + ball.radius > paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                    ball.dy = -Math.abs(ball.dy);
                    const hitPos = (ball.x - paddle.x) / paddle.width;
                    ball.dx = (hitPos - 0.5) * 8;
                    // small bonus for center hits
                    if (Math.abs(hitPos - 0.5) < 0.16) {
                        score += 5;
                        scoreEl.textContent = score;
                    }
                }

                // brick collisions (simple box check). When hit, invert dy, destroy brick and spawn particles
                for (let r = 0; r < brickRows; r++) {
                    for (let c = 0; c < brickCols; c++) {
                        const b = bricks[r][c];
                        if (!b || b.status === 0) continue;
                        if (
                            ball.x + ball.radius > b.x &&
                            ball.x - ball.radius < b.x + brickWidth &&
                            ball.y + ball.radius > b.y &&
                            ball.y - ball.radius < b.y + brickHeight
                        ) {
                            // simple overlap check to decide reflection axis (prefer y inversion)
                            const overlapX = Math.min(ball.x + ball.radius - b.x, b.x + brickWidth - (ball.x - ball.radius));
                            const overlapY = Math.min(ball.y + ball.radius - b.y, b.y + brickHeight - (ball.y - ball.radius));
                            if (overlapX < overlapY) ball.dx *= -1; else ball.dy *= -1;

                            // destroy and score
                            b.status = 0;
                            score += 10;
                            scoreEl.textContent = score;

                            // particles at brick center
                            createParticles(b.x + brickWidth / 2, b.y + brickHeight / 2, b.color, 14);

                            // exit loops to avoid multiple hits same frame
                            return;
                        }
                    }
                }

                // fall below -> game over and reset
                if (ball.y - ball.radius > canvas.height) {
                    gameRunning = false;
                    setTimeout(() => alert('ゲームオーバー！ スコア: ' + score), 120);
                    resetGame();
                }

                // clear check handled in gameLoop
            }

            // --- Render ---
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // background
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawBricks();
                drawParticles();
                drawPaddle();
                drawBall();
            }

            // --- Game loop ---
            function gameLoop() {
                if (!gameRunning) return;
                movePaddle();
                moveBall();
                updateParticles();
                draw();

                // check clear
                if (bricks.every(row => row.every(b => !b || b.status === 0))) {
                    // simple reset: reinit bricks and continue
                    initBricks();
                    // small ball speed up
                    ball.dx *= 1.05;
                    ball.dy *= 1.05;
                    // clear particles
                    particles = [];
                }

                animationId = requestAnimationFrame(gameLoop);
            }

            // --- Controls ---
            function startGame() {
                if (gameRunning) return;
                gameRunning = true;
                gameLoop();
            }

            function resetGame() {
                gameRunning = false;
                if (animationId) cancelAnimationFrame(animationId);
                score = 0; scoreEl.textContent = score;

                paddle.x = canvas.width / 2 - 40;
                paddle.dx = 0;

                ball.x = canvas.width / 2;
                ball.y = canvas.height / 2;
                ball.dx = 3;
                ball.dy = -3;
                ball.trail = [];

                particles = [];

                // recalc brick width (in case canvas changed)
                brickWidth = Math.floor((canvas.width - brickOffsetLeft * 2 - (brickCols - 1) * brickPadding) / brickCols);

                initBricks();
                draw();
            }

            // --- Input handlers ---
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') paddle.dx = -paddle.speed;
                if (e.key === 'ArrowRight') paddle.dx = paddle.speed;
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') paddle.dx = 0;
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                paddle.x = mouseX - paddle.width / 2;
                if (paddle.x < 0) paddle.x = 0;
                if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
            });

            startBtn.addEventListener('click', startGame);
            resetBtn.addEventListener('click', resetGame);

            
            initBricks();
            draw();

        })();
    </script>
</body>

</html>
