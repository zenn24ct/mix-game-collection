<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>blockgame01(2026 01)</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0
        }

        body {
            font-family: Arial, sans-serif;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: #f3f4f6
        }

        .wrap {
            width: 520px
        }

        h1 {
            color: #334155;
            text-align: center;
            margin-bottom: 12px;
            font-size: 20px
        }

        canvas {
            display: block;
            border: 3px solid #667eea;
            border-radius: 8px;
            background: #fff;
            margin: 0 auto
        }

        .info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 14px
        }

        #score {
            color: #667eea;
            font-weight: 700;
            font-size: 20px
        }

        button {
            padding: 8px 14px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 700
        }

        #start {
            background: #667eea;
            color: #fff
        }

        #reset {
            background: #ef4444;
            color: #fff
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1>2026年1個目のブロック崩し（エフェクト付き）</h1>
        <canvas id="c" width="480" height="600"></canvas>
        <div class="info">
            <div>スコア: <span id="score">0</span></div>
            <div>
                <button id="start">スタート</button>
                <button id="reset">リセット</button>
            </div>
        </div>
    </div>

    <script>
        (function () {
            // --- DOM ---
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            const scoreEl = document.getElementById('score');
            const startBtn = document.getElementById('start');
            const resetBtn = document.getElementById('reset');

            // --- State ---
            let score = 0;
            let gameRunning = false;
            let animationId = null;

            // --- Paddle ---
            const paddle = { x: canvas.width / 2 - 40, y: canvas.height - 30, width: 80, height: 10, speed: 7, dx: 0 };

            // --- Ball (with trail) ---
            const ball = { x: canvas.width / 2, y: canvas.height / 2, radius: 6, dx: 3, dy: -3, trail: [] };

            // --- Particles ---
            let particles = []; // {x,y,vx,vy,color,life}

            // --- Bricks config ---
            const brickRows = 8, brickCols = 8, brickPadding = 5, brickOffsetTop = 40, brickOffsetLeft = 10;
            let brickWidth = Math.floor((canvas.width - brickOffsetLeft * 2 - (brickCols - 1) * brickPadding) / brickCols);
            const brickHeight = 20;
            let bricks = [];

            // --- Init bricks ---
            function initBricks() {
                bricks = [];
                const colors = ['#e74c3c', '#e67e22', '#f39c12', '#27ae60', '#4bb7ff', '#d381f4', '#ff7ffd', '#ff3e6b'];
                for (let r = 0; r < brickRows; r++) {
                    bricks[r] = [];
                    for (let c = 0; c < brickCols; c++) {
                        bricks[r][c] = {
                            x: brickOffsetLeft + c * (brickWidth + brickPadding),
                            y: brickOffsetTop + r * (brickHeight + brickPadding),
                            status: 1,
                            color: colors[r] || '#999'
                        };
                    }
                }
            }

            // --- Particles: creation, update, draw ---
            function createParticles(x, y, color, count = 12) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.6) * 6,
                        color: color,
                        life: 1
                    });
                }
            }

            function updateParticles() {
                particles = particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.18;    // gravity
                    p.vx *= 0.99;    // slight air drag
                    p.life -= 0.03;
                    return p.life > 0;
                });
            }

            function drawParticles() {
                for (const p of particles) {
                    ctx.globalAlpha = Math.max(0, p.life);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 3, 3);
                }
                ctx.globalAlpha = 1;
            }

            // --- Draw functions (including ball trail) ---
            function drawPaddle() {
                ctx.fillStyle = '#667eea';
                ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            }

            function drawBall() {
                // add current position to trail
                ball.trail.push({ x: ball.x, y: ball.y });
                if (ball.trail.length > 10) ball.trail.shift();

                // draw trail (from oldest to newest -> faint -> strong)
                for (let i = 0; i < ball.trail.length; i++) {
                    const t = ball.trail[i];
                    const alpha = (i / ball.trail.length) * 0.5; // 0..0.5
                    const r = ball.radius * (i / ball.trail.length * 0.8 + 0.2);
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, Math.max(1, r), 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(231,76,60,${alpha})`;
                    ctx.fill();
                    ctx.closePath();
                }

                // main ball
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.closePath();
            }

            function drawBricks() {
                for (let r = 0; r < brickRows; r++) {
                    for (let c = 0; c < brickCols; c++) {
                        const b = bricks[r][c];
                        if (!b || b.status === 0) continue;
                        ctx.fillStyle = b.color;
                        ctx.fillRect(b.x, b.y, brickWidth, brickHeight);
                        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(b.x, b.y, brickWidth, brickHeight);
                    }
                }
            }

            // --- Movement & collisions ---
            function movePaddle() {
                paddle.x += paddle.dx;
                if (paddle.x < 0) paddle.x = 0;
                if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
            }

            function moveBall() {
                ball.x += ball.dx;
                ball.y += ball.dy;

                // wall collisions
                if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.dx *= -1;
                if (ball.y - ball.radius < 0) ball.dy *= -1;

                // paddle collision
                if (ball.y + ball.radius > paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                    ball.dy = -Math.abs(ball.dy);
                    const hitPos = (ball.x - paddle.x) / paddle.width;
                    ball.dx = (hitPos - 0.5) * 8;
                    // small bonus for center hits
                    if (Math.abs(hitPos - 0.5) < 0.16) {
                        score += 5;
                        scoreEl.textContent = score;
                    }
                }

                // brick collisions (simple box check). When hit, invert dy, destroy brick and spawn particles
                for (let r = 0; r < brickRows; r++) {
                    for (let c = 0; c < brickCols; c++) {
                        const b = bricks[r][c];
                        if (!b || b.status === 0) continue;
                        if (
                            ball.x + ball.radius > b.x &&
                            ball.x - ball.radius < b.x + brickWidth &&
                            ball.y + ball.radius > b.y &&
                            ball.y - ball.radius < b.y + brickHeight
                        ) {
                            // simple overlap check to decide reflection axis (prefer y inversion)
                            const overlapX = Math.min(ball.x + ball.radius - b.x, b.x + brickWidth - (ball.x - ball.radius));
                            const overlapY = Math.min(ball.y + ball.radius - b.y, b.y + brickHeight - (ball.y - ball.radius));
                            if (overlapX < overlapY) ball.dx *= -1; else ball.dy *= -1;

                            // destroy and score
                            b.status = 0;
                            score += 10;
                            scoreEl.textContent = score;

                            // particles at brick center
                            createParticles(b.x + brickWidth / 2, b.y + brickHeight / 2, b.color, 14);

                            // exit loops to avoid multiple hits same frame
                            return;
                        }
                    }
                }

                // fall below -> game over and reset
                if (ball.y - ball.radius > canvas.height) {
                    gameRunning = false;
                    setTimeout(() => alert('ゲームオーバー！ スコア: ' + score), 120);
                    resetGame();
                }

                // clear check handled in gameLoop
            }

            // --- Render ---
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // background
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawBricks();
                drawParticles();
                drawPaddle();
                drawBall();
            }

            // --- Game loop ---
            function gameLoop() {
                if (!gameRunning) return;
                movePaddle();
                moveBall();
                updateParticles();
                draw();

                // check clear
                if (bricks.every(row => row.every(b => !b || b.status === 0))) {
                    // simple reset: reinit bricks and continue
                    initBricks();
                    // small ball speed up
                    ball.dx *= 1.05;
                    ball.dy *= 1.05;
                    // clear particles
                    particles = [];
                }

                animationId = requestAnimationFrame(gameLoop);
            }

            // --- Controls ---
            function startGame() {
                if (gameRunning) return;
                gameRunning = true;
                gameLoop();
            }

            function resetGame() {
                gameRunning = false;
                if (animationId) cancelAnimationFrame(animationId);
                score = 0; scoreEl.textContent = score;

                paddle.x = canvas.width / 2 - 40;
                paddle.dx = 0;

                ball.x = canvas.width / 2;
                ball.y = canvas.height / 2;
                ball.dx = 3;
                ball.dy = -3;
                ball.trail = [];

                particles = [];

                // recalc brick width (in case canvas changed)
                brickWidth = Math.floor((canvas.width - brickOffsetLeft * 2 - (brickCols - 1) * brickPadding) / brickCols);

                initBricks();
                draw();
            }

            // --- Input handlers ---
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') paddle.dx = -paddle.speed;
                if (e.key === 'ArrowRight') paddle.dx = paddle.speed;
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') paddle.dx = 0;
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                paddle.x = mouseX - paddle.width / 2;
                if (paddle.x < 0) paddle.x = 0;
                if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
            });

            startBtn.addEventListener('click', startGame);
            resetBtn.addEventListener('click', resetGame);

            // --- Init ---
            initBricks();
            draw();

        })();
    </script>
</body>

</html>
